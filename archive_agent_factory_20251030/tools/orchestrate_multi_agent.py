"""
Tool #14: Orchestrate Multi-Agent

This tool handles coordination and communication between multiple agents
in multi-agent systems.
"""

from typing import Dict, List, Any, Optional
from pydantic import BaseModel, Field
from loguru import logger
from pathlib import Path
from enum import Enum


class CommunicationPattern(str, Enum):
    """Communication patterns between agents"""
    SEQUENTIAL = "sequential"
    PARALLEL = "parallel"
    CONDITIONAL = "conditional"
    EVENT_DRIVEN = "event_driven"


class AgentInteraction(BaseModel):
    """Model for agent-to-agent interaction"""
    from_agent: str = Field(..., description="Source agent name")
    to_agent: str = Field(..., description="Target agent name")
    data_flow: str = Field(..., description="What data flows between agents")
    pattern: CommunicationPattern = Field(..., description="Communication pattern")
    priority: int = Field(1, description="Execution priority")


class OrchestrationConfig(BaseModel):
    """Model for orchestration configuration"""
    agents: List[str] = Field(..., description="List of agent names")
    interactions: List[AgentInteraction] = Field(..., description="Agent interactions")
    entry_point: str = Field(..., description="Entry point agent")
    error_handling: str = Field("retry", description="Error handling strategy")


class OrchestrationResult(BaseModel):
    """Model for orchestration result"""
    orchestrator_code: str = Field(..., description="Generated orchestrator code")
    workflow_diagram: str = Field(..., description="Workflow diagram (mermaid)")
    config_file: str = Field(..., description="Configuration file content")
    files_generated: List[str] = Field(default_factory=list, description="Generated files")


class OrchestrateMultiAgentTool:
    """
    Tool for orchestrating multi-agent systems
    
    Features:
    - Agent communication patterns
    - Workflow coordination
    - Data flow management
    - Error handling across agents
    - State management
    """
    
    def __init__(self):
        """Initialize the orchestration tool"""
        logger.info("Initializing OrchestrateMultiAgentTool")
    
    def create_orchestrator(
        self,
        config: OrchestrationConfig,
        output_dir: Path
    ) -> OrchestrationResult:
        """
        Create an orchestrator for multiple agents
        
        Args:
            config: Orchestration configuration
            output_dir: Directory for output files
            
        Returns:
            OrchestrationResult with generated code
        """
        logger.info("Creating multi-agent orchestrator")
        logger.info(f"  Agents: {len(config.agents)}")
        logger.info(f"  Interactions: {len(config.interactions)}")
        logger.info(f"  Entry point: {config.entry_point}")
        
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Generate orchestrator code
        orchestrator_code = self._generate_orchestrator_code(config)
        
        # Generate workflow diagram
        workflow_diagram = self._generate_workflow_diagram(config)
        
        # Generate configuration file
        config_file = self._generate_config_file(config)
        
        # Save files
        files_generated = []
        
        # Save orchestrator
        orchestrator_path = output_dir / "orchestrator.py"
        orchestrator_path.write_text(orchestrator_code)
        files_generated.append(str(orchestrator_path))
        logger.info(f"  ✓ Generated: {orchestrator_path}")
        
        # Save workflow diagram
        diagram_path = output_dir / "workflow.md"
        diagram_path.write_text(workflow_diagram)
        files_generated.append(str(diagram_path))
        logger.info(f"  ✓ Generated: {diagram_path}")
        
        # Save config
        config_path = output_dir / "orchestration_config.json"
        config_path.write_text(config_file)
        files_generated.append(str(config_path))
        logger.info(f"  ✓ Generated: {config_path}")
        
        logger.info(f"✓ Orchestrator created")
        
        return OrchestrationResult(
            orchestrator_code=orchestrator_code,
            workflow_diagram=workflow_diagram,
            config_file=config_file,
            files_generated=files_generated
        )
    
    def _generate_orchestrator_code(self, config: OrchestrationConfig) -> str:
        """Generate orchestrator Python code"""
        code = f'''"""
Multi-Agent Orchestrator

Coordinates execution of {len(config.agents)} agents with {len(config.interactions)} interactions.
Auto-generated by Meta-Agent.
"""

import os
from typing import Dict, Any, Optional
from loguru import logger
from enum import Enum


class AgentStatus(str, Enum):
    """Agent execution status"""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"


class AgentOrchestrator:
    """Orchestrates multiple agents"""
    
    def __init__(self):
        """Initialize orchestrator"""
        self.agents = {{}}
        self.agent_status = {{}}
        self.results = {{}}
        
        # Initialize agents
        self._initialize_agents()
    
    def _initialize_agents(self):
        """Initialize all agents"""
        logger.info("Initializing agents...")
        
'''
        
        # Add agent initialization
        for agent in config.agents:
            code += f'''        # Initialize {agent}
        try:
            from agents.{agent.lower()} import {agent}
            self.agents["{agent}"] = {agent}()
            self.agent_status["{agent}"] = AgentStatus.PENDING
            logger.info(f"  ✓ {{'{agent}'}} initialized")
        except Exception as e:
            logger.error(f"  ✗ Failed to initialize {{'{agent}'}}: {{e}}")
            self.agents["{agent}"] = None
            self.agent_status["{agent}"] = AgentStatus.FAILED
        
'''
        
        # Add orchestration methods
        code += f'''    
    def execute(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute the multi-agent workflow
        
        Args:
            input_data: Initial input data
            
        Returns:
            Final results
        """
        logger.info("="*70)
        logger.info("Starting Multi-Agent Orchestration")
        logger.info("="*70)
        
        try:
            # Start with entry point agent
            result = self._execute_agent("{config.entry_point}", input_data)
            
            # Execute workflow
            result = self._execute_workflow(result)
            
            logger.info("="*70)
            logger.info("✓ Orchestration Complete")
            logger.info("="*70)
            
            return result
            
        except Exception as e:
            logger.error(f"❌ Orchestration failed: {{e}}")
            return {{"error": str(e), "status": "failed"}}
    
    def _execute_agent(self, agent_name: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a single agent"""
        logger.info(f"Executing {{agent_name}}...")
        
        if agent_name not in self.agents or self.agents[agent_name] is None:
            logger.error(f"  Agent {{agent_name}} not available")
            return {{"error": f"Agent {{agent_name}} not initialized"}}
        
        try:
            self.agent_status[agent_name] = AgentStatus.RUNNING
            result = self.agents[agent_name].run(data)
            self.agent_status[agent_name] = AgentStatus.COMPLETED
            self.results[agent_name] = result
            
            logger.info(f"  ✓ {{agent_name}} completed")
            return result
            
        except Exception as e:
            logger.error(f"  ✗ {{agent_name}} failed: {{e}}")
            self.agent_status[agent_name] = AgentStatus.FAILED
            
            # Error handling: {config.error_handling}
            if "{config.error_handling}" == "retry":
                logger.info(f"  Retrying {{agent_name}}...")
                return self._execute_agent(agent_name, data)
            elif "{config.error_handling}" == "skip":
                return {{"error": str(e), "agent": agent_name}}
            else:
                raise
    
    def _execute_workflow(self, initial_result: Dict[str, Any]) -> Dict[str, Any]:
        """Execute the complete workflow"""
        current_result = initial_result
        
'''
        
        # Add interaction execution based on patterns
        for interaction in config.interactions:
            if interaction.pattern == CommunicationPattern.SEQUENTIAL:
                code += f'''        # Sequential: {interaction.from_agent} -> {interaction.to_agent}
        if self.agent_status["{interaction.from_agent}"] == AgentStatus.COMPLETED:
            current_result = self._execute_agent("{interaction.to_agent}", current_result)
        
'''
        
        code += f'''        
        return current_result
    
    def get_status(self) -> Dict[str, str]:
        """Get status of all agents"""
        return {{agent: status.value for agent, status in self.agent_status.items()}}


def main():
    """Main execution"""
    orchestrator = AgentOrchestrator()
    
    # Example input
    input_data = {{
        "request": "Process data",
        "timestamp": "2025-01-01T00:00:00"
    }}
    
    # Execute
    result = orchestrator.execute(input_data)
    
    # Print results
    print("\\nOrchestration Results:")
    print("="*70)
    for key, value in result.items():
        print(f"{{key}}: {{value}}")
    print("="*70)
    
    # Print status
    print("\\nAgent Status:")
    print("="*70)
    status = orchestrator.get_status()
    for agent, state in status.items():
        print(f"{{agent}}: {{state}}")
    print("="*70)


if __name__ == "__main__":
    main()
'''
        
        return code
    
    def _generate_workflow_diagram(self, config: OrchestrationConfig) -> str:
        """Generate Mermaid workflow diagram"""
        diagram = f"""# Multi-Agent Workflow Diagram

```mermaid
graph TD
    Start([Start]) --> {config.entry_point}
"""
        
        # Add interactions
        for interaction in config.interactions:
            arrow_style = "-->"
            if interaction.pattern == CommunicationPattern.PARALLEL:
                arrow_style = "-..->"
            elif interaction.pattern == CommunicationPattern.CONDITIONAL:
                arrow_style = "==>"
            
            diagram += f"    {interaction.from_agent} {arrow_style} {interaction.to_agent}\n"
        
        # Find terminal agents (no outgoing edges)
        outgoing_agents = {i.from_agent for i in config.interactions}
        terminal_agents = [a for a in config.agents if a not in outgoing_agents or a == config.entry_point]
        
        for agent in terminal_agents:
            if agent != config.entry_point:
                diagram += f"    {agent} --> End([End])\n"
        
        diagram += "```\n\n## Legend\n\n"
        diagram += "- `-->` Sequential execution\n"
        diagram += "- `-.->` Parallel execution\n"
        diagram += "- `==>` Conditional execution\n"
        
        return diagram
    
    def _generate_config_file(self, config: OrchestrationConfig) -> str:
        """Generate JSON configuration file"""
        import json
        
        config_dict = {
            "agents": config.agents,
            "entry_point": config.entry_point,
            "error_handling": config.error_handling,
            "interactions": [
                {
                    "from": i.from_agent,
                    "to": i.to_agent,
                    "data_flow": i.data_flow,
                    "pattern": i.pattern.value,
                    "priority": i.priority
                }
                for i in config.interactions
            ]
        }
        
        return json.dumps(config_dict, indent=2)


def create_multi_agent_orchestrator(
    agents: List[str],
    interactions: List[AgentInteraction],
    entry_point: str,
    output_dir: Path
) -> OrchestrationResult:
    """
    Convenience function to create orchestrator
    
    Args:
        agents: List of agent names
        interactions: Agent interactions
        entry_point: Entry point agent
        output_dir: Output directory
        
    Returns:
        OrchestrationResult
    """
    config = OrchestrationConfig(
        agents=agents,
        interactions=interactions,
        entry_point=entry_point
    )
    
    tool = OrchestrateMultiAgentTool()
    return tool.create_orchestrator(config, output_dir)

